// Class that can generate a histogram of some other image descriptor
// given a dictionary. The histogram is generated by doing an
// approximate nearest neighbour classification to a set of dictionary
// entries.
//
// This template class is parameterized by the
// ImageDescriptorGenerator needed to extract that raw descriptors
// that need to be bucketed for a histogram.
//
// Author: Mark Desnoyer
// Date: Sept 2010

#ifndef _SPECIES_ID_HISTOGRAM_DESCRIPTOR_GENERATOR_INL_H_
#define _SPECIES_ID_HISTOGRAM_DESCRIPTOR_GENERATOR_INL_H_

#include "HistogramDescriptorGenerator.h"
#include <boost/scoped_array.hpp>
#include <boost/unordered_map.hpp>
#include <fstream>
#include <iostream>
#include <ros/ros.h>
#include "cv_utils/HashFuncs.h"

using namespace boost;
using namespace std;

namespace species_id {

// A nearest neighbour lookup cache
template <typename T>
class NNCache {
public:
  // Create the cache around the index
  NNCache(flann::Index<T>* index, int checks)
    : index_(index), checks_(checks), cache_(), descriptorSize_(0) {}

  // Looks up the nearest neighbour to the descriptor and 
  // and returns the location of that entry
  int SearchNN(const ImageDescriptor<T>& descriptor) const;

private:
  flann::Index<T>* index_; // Nearest neighbour index
  int checks_; // Number of times to traverse the index

  mutable unordered_map<cv::Point2f, int> cache_;

  // Keep these around to make multiple lookups avoid reallocations
  mutable int descriptorSize_;
  mutable scoped_array<T> descriptorBuf_;
  mutable scoped_ptr<flann::Matrix<T> > curDescriptor_;
};

template<typename T>
int NNCache<T>::SearchNN(const ImageDescriptor<T>& descriptor) const {
  ROS_ASSERT(descriptor.hasValidPoint());
  unordered_map<cv::Point2f, int>::const_iterator entryLoc =
    cache_.find(descriptor.point());
  if (entryLoc == cache_.end()) {
    // TODO(mdesnoyer): If we're slow, this buffer (and the associated
    // copy) are probably not needed when we're using floats, but it's
    // not guaranteed because the flann library doesn't use const
    // correctness.

    // See if the buffers have been initialized properly
    if (descriptorSize_ != descriptor.DescriptorSize()) {
      descriptorSize_ = descriptor.DescriptorSize();
      descriptorBuf_.reset(new T[descriptorSize_]);
      curDescriptor_.reset(new flann::Matrix<T>(descriptorBuf_.get(), 1,
                                                descriptorSize_));
    }

    // Look up the descriptor in the knn index
    for (int i = 0; i < descriptorSize_; ++i) {
      (*curDescriptor_)[0][i] = descriptor.GetVal(i);
    }

    float dist;
    flann::Matrix<float> dists(&dist, 1, 1);
    int wordIdx;
    flann::Matrix<int> indicies(&wordIdx, 1, 1);
    
    index_->knnSearch(*curDescriptor_,
                      indicies,
                      dists,
                      1, // Number of neighbours to return,
                      flann::SearchParams(checks_));

    cache_[descriptor.point()] = wordIdx;

    return wordIdx;    
  }

  return entryLoc->second;
    
}

template <typename T>
HistogramDescriptorGenerator<T>::~HistogramDescriptorGenerator() {
}

template <typename T>
HistogramDescriptorGenerator<T>*
HistogramDescriptorGenerator<T>::CreateFromINRIADictionary(
    ImageDescriptorGenerator<T>* rawGenerator,
    const StringPiece& filename,
    float targetPrecision,
    float buildWeight,
    float memoryWeight,
    bool trackCoords) {
  flann::AutotunedIndexParams indexParams(targetPrecision,
                                          buildWeight,
                                          memoryWeight,
                                          1.0);  // Sample fraction
  return CreateFromINRIADictionary(rawGenerator, filename,
                                   indexParams,
                                   32,
                                   trackCoords);
}

template <typename T>
HistogramDescriptorGenerator<T>*
HistogramDescriptorGenerator<T>::CreateFromINRIADictionary(
    ImageDescriptorGenerator<T>* rawGenerator,
    const StringPiece& filename,
    const flann::IndexParams& indexParams,
    int checks,
    bool trackCoords) {

  // Load up the size of the dictionary from the text file
  ROS_INFO_STREAM("Opening dictionary file: " << filename.as_string());
  ifstream dataStream;
  dataStream.open(filename.as_string().c_str(), ifstream::in);

  HistogramDescriptorGenerator<T>* retval =
    CreateFromINRIADictionary(rawGenerator,
                              dataStream,
                              indexParams,
                              checks,
                              trackCoords);

  dataStream.close();
  return retval;
}

template <typename T>
HistogramDescriptorGenerator<T>*
HistogramDescriptorGenerator<T>::CreateFromINRIADictionary(
    ImageDescriptorGenerator<T>* rawGenerator,
    istream& stream,
    float targetPrecision,
    float buildWeight,
    float memoryWeight,
    bool trackCoords) {
  flann::AutotunedIndexParams indexParams(targetPrecision,
                                          buildWeight,
                                          memoryWeight,
                                          1.0);  // Sample fraction
  return CreateFromINRIADictionary(rawGenerator, stream,
                                   indexParams, 32, trackCoords);
}

template <typename T>
HistogramDescriptorGenerator<T>*
HistogramDescriptorGenerator<T>::CreateFromINRIADictionary(
    ImageDescriptorGenerator<T>* rawGenerator,
    istream& stream,
    const flann::IndexParams& indexParams,
    int checks,
    bool trackCoords) {
  flann::log_verbosity(LOG_INFO);

  uint64_t vectorDimension;
  uint64_t dictSize;

  stream >> skipws >> vectorDimension >> dictSize;

  if (vectorDimension <= 0 || dictSize <= 0) {
    ROS_ERROR_STREAM("Invalid dictionary size. Vector: "
                     << vectorDimension
                     << " entries: "
                     << dictSize);
    return NULL;
  }
  ROS_INFO_STREAM("Found a dictionary that has "
                  << dictSize 
                  << " entries of dimension "
                  << vectorDimension);

  // Allocate the dictionary
  scoped_array<T> dictBuf(new float[dictSize*vectorDimension]);
  flann::Matrix<T> dict(dictBuf.get(), dictSize, vectorDimension);
  
  // Load up the dictionary values
  unsigned long curEntry = 0;
  unsigned long curDim = 0;
  while(!stream.eof() && stream.good() &&
        curEntry < dictSize) {
    stream >> skipws >> dict[curEntry][curDim++];
    if (curDim >= vectorDimension) {
      curDim = 0;
      curEntry++;
    }
  }
  if (stream.fail()) {
    ROS_ERROR_STREAM("Error reading from stream");
  }

  if (curEntry != dictSize &&
      curDim != vectorDimension) {
    ROS_ERROR_STREAM("Dictionary read was an unexpected size. Expected: "
                     << dictSize << " entries of dimension "
                     << vectorDimension
                     << ". Read " << curEntry * curDim << " total values.");
                     return NULL;
  }

  

  ROS_INFO("Building the flann index");
  boost::scoped_ptr<flann::Index<T> > index(new flann::Index<T>(dict, indexParams));
  index->buildIndex();

  // Create the object to return
  HistogramDescriptorGenerator* generator =
    new HistogramDescriptorGenerator(rawGenerator);
  swap(generator->index_, index);
  generator->dictSize_ = dictSize;
  swap(generator->dictBuf_, dictBuf);
  generator->checks_ = checks;
  generator->trackCoords_ = trackCoords;

  return generator;
}

template <typename T>
template <typename DescriptorT>
void HistogramDescriptorGenerator<T>::ExtractUsingMasksImpl(
    const cv::Mat& image,
    const MaskCollection& masks,
    std::vector<boost::shared_ptr<DescriptorT> >* descriptors) const {

  // First get the raw descriptors from the image
  vector<shared_ptr<DescriptorCollection> > rawDescriptors;
  rawGenerator_->ExtractUsingMasks(image, masks, &rawDescriptors);

  // Now, for each of the masks, build up a histogram
  nnCache_.reset(new NNCache<T>(index_.get(), checks_));
  for (vector<shared_ptr<DescriptorCollection> >::const_iterator collectionI =
         rawDescriptors.begin();
       collectionI != rawDescriptors.end();
       ++collectionI) {
    
    // Create the histogram object
    HistDescriptorPtr histPtr(
      new HistogramImageDescriptor(dictSize_));

    // Now load up the histogram
    for (vector<DescriptorPtr>::const_iterator descI =
           (**collectionI).begin();
         descI != (**collectionI).end();
         ++descI) {
      histPtr->AddVal(nnCache_->SearchNN(**descI), 1.0,
                      (trackCoords_ && (*descI)->hasValidPoint()) ?
                       &(*descI)->point() : NULL);
    }

    histPtr->Normalize();
    
    // Append the histogram feature to the results
    shared_ptr<DescriptorT> descriptorCollection(
      new DescriptorT());
    descriptorCollection->push_back(histPtr);
    descriptors->push_back(descriptorCollection);
  }
}

template <typename T>
void HistogramDescriptorGenerator<T>::InitializeForWholeImage(
  const cv::Mat& image, const cv::Mat_<uint8>& mask) {
  rawGenerator_->InitializeForWholeImage(image, mask);
  nnCache_.reset(new NNCache<T>(index_.get(), checks_));
}

template <typename T>
void HistogramDescriptorGenerator<T>::ExtractFromSingleMask(
    const cv::Mat& image,
    const reefbot_msgs::ImageRegion& mask,
    DescriptorCollection* collection) const {
  ROS_ASSERT(collection);

  collection->push_back(ExtractHistogramFromSingleMask(image, mask));
}

template <typename T>
HistogramImageDescriptor::Ptr HistogramDescriptorGenerator<T>::ExtractHistogramFromSingleMask(
    const cv::Mat& image,
    const reefbot_msgs::ImageRegion& mask) const {
  HistDescriptorPtr retval(new HistogramImageDescriptor(dictSize_));

  // First extract the list of descriptors from the raw generator
  DescriptorCollection descriptors;
  rawGenerator_->ExtractFromSingleMask(image, mask, &descriptors);

  // Now build up the histogram
  for (DescriptorCollection::const_iterator descI = descriptors.begin();
       descI != descriptors.end(); ++descI) {
    retval->AddVal(nnCache_->SearchNN(**descI), 1.0,
                   (trackCoords_ && (*descI)->hasValidPoint()) ?
                   &(*descI)->point() : NULL);
  }

  retval->Normalize();

  return retval;
}

template <typename T>
void HistogramDescriptorGenerator<T>::ExtractFromWholeImage(
    const cv::Mat& image,
    const std::vector<cv::KeyPoint>& keypoints,
    DescriptorCollection* descriptors) const {
  // This shouldn't be called
  ROS_ASSERT(false);
}

}

#endif // _SPECIES_ID_HISTOGRAM_DESCRIPTOR_GENERATOR_INL_H_
